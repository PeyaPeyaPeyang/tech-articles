---
title: "JVM を読む | JVM の構造その２ - データ領域について"
emoji: "🖥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["java", "jvm", "jal"]
published: true
---

前回の続きです。前回はこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-02-1-4 

このシリーズは，JVM の仕様書を読み解くためのガイドとして構成しています。
JVM の仕様書は非常に長大で難解な内容が多いため，各セクションごとに要点をまとめていきます。
また，JVM の内部構造や動作原理を知ることで，Java のパフォーマンスやセキュリティ，メモリ管理の仕組みを深く理解する試みです。

シリーズはこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-00

## 第二章 The Structure of the Java Virtual Machine

JVM の仕様書の第２章は「Java Virtual Machine の構造」です。
といいましてもこの章は全７章ある JVM の仕様書の中でも特に長く，また特に複雑な内容ですので，全８回に分けて解説していきます。

ここでは Chapter 2.5 の内容（実行時時のデータ領域）を扱います。

## 2.5 実行時のデータ領域（[› 2.5 Runtime Data Areas](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-2.html#jvms-2.5)）

JVM は実行時に様々な**データ領域**にアクセスします。
データ領域は，格納するものによって次のように分類されます：

+ **JVM 全体**に存在するもの：JVM の起動時に割り当てられ，プログラムの実行中に共有されます。
  - ヒープ
  - メソッド領域
  - 実行時定数プール
+ **スレッドごと**に存在するもの：スレッドの作成時に割り当てられ，スレッドの終了時に解放されます。
  - `pc` レジスタ
  - JVM スタック
  - ネイティブ・メソッド・スタック
+ **クラスごと**に存在するもの：クラスがロードされるときに割り当てられ，クラスのアンロード時に解放されます。
  - 実行時定数プール
  - クラスのメタデータ

これらのデータ領域は JVM の実行時に必要な情報を格納し，プログラムの実行をサポートします。

![JVM のデータ領域の関係図](/images/reading-jvm-chapter-02-5/jvm.png)

### ヒープ（JVM 全体）

JVM は，すべてのスレッドで共有される「ヒープ」（Heap）領域を持ちます。
全てのクラス・インスタンスと配列の実体がこの領域に格納されます。
ヒープは JVM の起動時に作成され，プログラムの実行中に動的に拡張されることがあります。

ヒープ内に格納される要素の割り当てと解放は，**ガーベジ・コレクション・システム**によって自動的に行われます。 ガベージ・コレクション（GC）とは，不要なオブジェクトを自動的に検出して解放する仕組みのことです。 ガベージ・コレクタ（後述）という特別なコンポーネントがこの役割を担います。

:::message
JVM 仕様では，ガベージ・コレクタの具体的な実装やアルゴリズムの定義は行われていません。
また，ヒープのサイズの制限もありませんし，ヒープ用のメモリ配置が連続している必要もありません（メモリ配置が離散的であってもよいのです）。

ただし，使用できるヒープサイズ以上のオブジェクトを必要とする場合には，JVM は `OutOfMemoryError` をスローします。
:::

#### ぺやんぐ注

ヒープや JVM に関するよくある説明において，例えば *Eden* 領域や *Survivor* 領域，*Old* 領域などに関する詳細な説明を目にします。
これらは，あくまでも１つの JVM 実装である *HotSpot JVM* に特有の概念であり，他の VM 実装では異なる場合があります。

ヒープをこれらの領域に区切って管理するということは，実は **JVM 仕様書では一切定義されていません**。
ヒープはただ単に「**オブジェクトの実体が格納される領域**」とだけ説明されており，その実装は JVM の実装者に任されています。
そのため，ヒープの実装は JVM の実装によって異なることが十分にあり得ます。

例えば G1GC（*Garbage-First Garbage Collector*）では，ヒープは複数の小さな領域（リージョン）に分割され，それぞれのリージョンが異なる世代（Young，Old，Humongous など）に属します。これらのリージョンは動的に割り当てられ，ガベージ・コレクションの際に異なる方法で管理されます。

さらに [ZGC（The Z Garbage Collector）](https://wiki.openjdk.org/display/zgc/Main) や [Shenandoah GC](https://wiki.openjdk.org/display/shenandoah/Main) などの新しいガベージ・コレクタでは，ヒープの管理方法がさらに異なります。
ZGC では，ヒープを `Small`，`Medium`，`Large` の３つのサイズ・クラスに分割し，それぞれのクラスに対して異なるガベージ・コレクション戦略を採用しています。
さらに Shenandoah GC では，ヒープを複数のリージョンに分割し，それぞれのリージョンが異なる世代に属します。

このように，ヒープの実装は JVM の実装によって大きく異なり，これが大変面白いのです。

（脚注おわり。）

### メソッド領域（JVM 全体）

JVM は，すべてのスレッドで共有される「メソッド領域」（Method Area）を持ちます。
実行時定数プールやフィールド，メソッドのデータ，およびクラスのメタデータ及び構造データなどの情報がこの領域に格納されます。

なお，これは（一応）ヒープ領域内に存在していますが，或る単純な実装ではガベージ・コレクションの対象外とすることもできます。
（なぜなら，クラスの構造やメタデータ，メソッドの定義は通常，プログラムの実行中に変更されない上に，明示的にアンロードされることもないからです。）

:::message
JVM 仕様では，メソッド領域のサイズを明示的に指定していません。
さらに，使用できるメソッド領域サイズ以上のメタデータを必要とする場合，JVM は `OutOfMemoryError` をスローします。
:::

### `pc` レジスタ（スレッドごと）

JVM は，各スレッドごとに `pc`（*Program Counter*）レジスタを持ちます。
これは，**現在実行している命令のアドレス**をスレッドが保持・管理するためのレジスタです。

各スレッドは，どの瞬間においても（或るメソッド内の）１つの命令を実行しています。
そのメソッドが `native` メソッドでない限りは，その命令のアドレスは常に `pc` レジスタによって指し示されます。
（`native` メソッドは JVM の外部で実行されるため，`pc` レジスタは使用されません。その場合には `pc` レジスタの値は不定です。）

### JVM スタック（スレッドごと）

JVM は，「JVM スタック」（Java Virtual Machine Stack）と呼ばれる領域を各スレッドごとに持ちます。

これは[フレーム](reading-jvm-chapter-02-6.md)を格納するためのスタック型のデータ構造です。
フレームとは，各メソッドの呼び出しごとに作成されるデータ構造で，そのメソッドの実行に必要な情報（ローカル変数，オペランドスタック，メソッドの戻り先など）を格納します。
詳しくは[JVM を読む | JVM の構造その３ - フレームについて](reading-jvm-chapter-02-6.md)をご覧ください。

或るメソッドが呼び出されると，そのメソッドのためのフレームが作成され，JVM スタックにプッシュ（追加）されます。
メソッドの実行が（正常に終了するか，例外がスローされるかに関わらず）完了すると，そのメソッドのフレームはポップ（削除）されます。

:::message
JVM 仕様では，スタックのサイズを明示的に指定していません。
すなわち，固定サイズにすることも，必要に応じて拡張することもできます。
（スタックのサイズは JVM の実装によって異なるため，スタックオーバーフローが発生する可能性があります。）
:::

### 実行時定数プール（クラスごと）

各クラスは，「実行時定数プール」（Runtime Constant Pool）と呼ばれる領域を持ちます。
これは，クラス・ファイルの `constant_pool` テーブルの値をクラス（またはインタフェース）ごとに展開して，実行時にJVM が参照できるようにしたものです。

`constant_pool` テーブルには，コンパイル時に析出したリテラル（文字列や数値など）やシンボル（クラス名，フィールド名，メソッド名など），および参照（クラス，フィールド，メソッドへの参照など）が格納されます。
![実行時定数プールのイメージ](/images/reading-jvm-chapter-02-5/constant-pool.png)
`UTF-8` は，文字列リテラルを格納するためのエントリです。これを `NameAndType` エントリや `MethodRef` エントリ，`FieldRef` エントリなどが参照します。

各実行時定数プールは，JVM の[メソッド領域](#メソッド領域jvm-全体)内に，クラスやインタフェースがロードされるときに作成されます。

:::message
なお，これも同様に使用できる実行時定数プールのサイズ以上の定数を必要とする場合，JVM は `OutOfMemoryError` をスローします。
:::

### ネイティブ・メソッド・スタック（スレッドごと）

JVM は，ネイティブ・メソッドを実行するためのネイティブ・メソッド・スタック（Native Method Stack）を持ちます。

ネイティブ・メソッドとは，Java 言語以外の言語（C や C++ など）で実装されたメソッドのことです。 JVM はこれを呼び出すために，従来の C 言語のスタックを使用します。

或る JVM の実装において，ネイティブ・メソッド・スタックを使用しない場合（そもそも呼び出せない，または自分自身が従来のスタックに依存しない場合）にはこれを実装する必要はありません。

:::message
なお，許容できるよりもより多くのネイティブ・メソッド・スタックを必要とする場合は，`StackOverflowError` をスローします。
またこの拡張を試みて，それにも失敗した場合は，`OutOfMemoryError` をスローします。
:::

## まとめ

いかがでしたか？
JVM の実行時のデータ領域は，プログラムの実行に必要な情報を格納するための重要なコンポーネントです。
これらのデータ領域は，JVM の動作を理解する上で非常に重要です。
次回は Chapter 2.6 の内容（フレーム）を扱います。

では，よいバイト・コードライフを！

#### 次回リンク

https://zenn.dev/peyang/articles/reading-jvm-chapter-02-6

#### 参考文献＆リンク集

+ Lindholm, T., Yellin, F., Bracha, G., & Smith, W. M. D. (2025). [*The Java® Virtual Machine Specification: Java SE 24 Edition*](https://docs.oracle.com/javase/specs/jvms/se24/html/).
+ Lindholm, T., & Yellin, F. (1999). *The Java™ Virtual Machine Specification* (2nd ed.). Addison-Wesley. ISBN 978-0-201-43294-7
+ Otavio, S. (2024). *Mastering the Java Virtual Machine*.  Packet Publishing. ISBN 978-1-835-46796-1
