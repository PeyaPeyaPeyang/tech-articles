---
title: "JVM を読む - 導入"
emoji: "🧬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["java", "jvm", "jal"]
published: true
---

前回の続きです。前回はこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-00

このシリーズは，JVM の仕様書を読み解くためのガイドとして構成しています。
JVM の仕様書は非常に長大で難解な内容が多いため，各セクションごとに要点をまとめていきます。
また，JVM の内部構造や動作原理を知ることで，Java のパフォーマンスやセキュリティ，メモリ管理の仕組みを深く理解する試みです。

# 第一章 Introduction

JVM の仕様書の最初のセクションは「Introduction」です。
このセクションでは，JVM の目的や設計目標，基本的な概念について説明されています。

## 1.1 歴史的な背景をちょっと（[› 1.1 A Bit of History](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.1))

Java 言語は，C や C++ のような低レベルの言語ではなく，それよりも手厚い高レベルな言語として設計されました。
特にこれらの言語はハードウェアに近いレベルでの制御が可能ですが，その分，メモリ管理やポインタ操作などの低レベルな概念を理解する必要があります（さらに安全なコードを書くためには，それらを正確に扱う必要があります）。
そのため全く持って複雑で，わかりにくく，また安全ではありません。

Java の設計者たちは，これらの問題を解決するために Java をより高レベルな言語として設計しました。

### Web の登場とその限界

ところで，この頃の Web 文章は HTML のみで書かれていました。
そのうえに，動的にコンテンツを生成する仕組み（例えば JavaScript のような）はありませんでした。
HTML は皆さん御存知の通り 静的なマークアップ言語ですから，ページに動的な要素（例えばボタンを押したときに何かが起こるなど）を追加することはできなかったのです。
これに Web の愛好家はすぐに気がつきました。新たな解決策が必要だったのです。

そこで登場したのが HotJava ブラウザをはじめとしたアプレット技術です。
これは HTML ページ内にプログラムを埋め込むことで，ページに動的な要素を追加できる画期的なものです。
ユーザがブラウザでアプレットが埋め込まれたページを開くと，HTML ページを読み込むとともに裏で Java プログラムがダウンロード・実行されます。
このようにしてページに動的なコンテンツがもたらされ，急速に普及していきました。

アプレットの普及の理由には，単に見栄えや機能が良いからというだけでなく，JVM アーキテクチャや Java のセキュリティモデルが大きく貢献しています。

#### 普及の理由その１：JVM のアーキテクチャ

アプレットはユーザの端末で実行される小さなプログラムです。
ということは，プログラムはあらゆるユーザが所有するマシンで動作することになります。

あらゆるマシンで完璧に動作するように，オプションを変えながら各マシン用のバイナリを都度コンパイルする必要があるのでしょう。
これに対応するのは非常に面倒で，また非効率的です。

:::message
もしここで使っているマシンのアンケートを取ったとしたら，私は「Intel x86 CPU で動く Windows 11」に投票しようと思いますが，
この記事を読んでいる皆さんは違った環境に投票をするかもしれません。
このようにユーザの環境は多様であり，それぞれに対応するのは骨の折れる作業です。
:::

そこで登場したのが JVM というわけです。
JVM は Java バイトコードを実行するための仮想マシンであり，Java プログラムは JVM 上で動作します。
さらに JVM はハードウェアに依存せず，一貫して同じバイトコードを実行できるので， JVM さえその環境に実装されていれば，一度コンパイルした同じ Java プログラムを実行できるのです。
これにより，Java プログラムは「Write Once, Run Anywhere」（一度書けばどこでも動く）という標語の如き機能を実現しました。

当時のアプレット技術は，この「Write Once, Run Anywhere」の特性を活かして，ユーザの端末で動作する動的なコンテンツを簡単に提供できました。

#### 普及の理由その２：Java のセキュリティモデル

先ほど述べたように，アプレットはユーザの端末で実行されます。 これは，アプレットがユーザのマシンに直接アクセスできることを意味します。
もし Web ページに埋め込まれたプログラムが，任意のユーザのファイルやシステムにアクセスできるとしたら，セキュリティ上の問題が発生します。
そこで Java は，**アプレットが実行される環境を制限するためのセキュリティモデル**を導入しました。

Java のセキュリティモデルは，アプレットが実行される環境を「サンドボックス」と呼びます。
サンドボックス内では，アプレットがユーザのファイルシステムやネットワークにアクセスすることが制限されます。

アプレットは，特定の権限を持つ場合にのみ，ユーザのマシンにアクセスできます。
例えば，アプレットがユーザのファイルシステムにアクセスするためには，ユーザが明示的に許可する必要があります。
このようにして，アプレットはユーザのマシンに対して安全に動作するのです。

このことが当時のギークたちに受け入れられると， Java 使っているページは安全であるという一種の信頼を得ることとなり，
これもまたアプレット技術の普及に寄与しました。

#### まとめ

アプレット技術は，JVM のアーキテクチャと Java のセキュリティモデルによって支えられています。
これにより，Java プログラムは「Write Once, Run Anywhere」の特性を持ち，ユーザの端末で安全に動作することが可能となりました。
いまでさえアプレット技術は廃れてしまいましたが，JVM のアーキテクチャと Java のセキュリティモデルは，Java 言語の基盤として受け継がれています。

## 1.2 Java 仮想マシン（[› 1.2 The Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.2)）

Java 仮想マシンは，Java プラットフォームの根幹となる技術です。
次のような特徴を持っています：

1. 特定のハードウェアやオペレーティング・システムなど，**環境に依存しない**こと
2. コンパイルされた**バイナリのサイズが小さい**こと
3. 悪意のあるプログラムからユーザを保護するための**セキュリティ機能を備えている**こと

これらの特徴により，Java 仮想マシンはプラットフォームに依存しないアプリケーションの最高な実行環境を提供します。

もっというと，Java 仮想マシンは抽象的な計算機です。
実際の電卓のように命令セットを持ち，実行時には様々なメモリ領域を操作します。

### JVM の最初の実装

Sun Microsystems 社は，Java 仮想マシンの最初の実装を開発しました。
この実装は現代の PDA（携帯電話のような見た目の小型コンピュータ。）に似ているデバイス上で動作し，Java 仮想マシンの命令をエミュレートしました。

Oracle 社がする現在の実装では，こういった環境に限らずモバイルやデスクトップ，サーバ上で Java 仮想マシンを実行します。
しかしながら Java 仮想マシンは依然として抽象的な計算機であり，特定の実装技術やホスト，ハードウェアやオペレーティング・システムに依存しません。
すなわち，例えばシリコン CPU やマイクロコードに直接実装することもできますし，他の言語で実装することも， JVM 上で JVM を実装することもできます。

:::message
例えば [PicoJava](https://picojava-ii.github.io/) は Java 仮想マシンの命令セットをハードウェアで直接実装したものです。
PicoJava は Sun Microsystems 社によって開発され，Java 仮想マシンの命令をハードウェアで直接実行します（!!!）
すなわち JVM の命令セットが**そのまま CPU 命令セットとして実装されている**のです。(!?!?)
:::

### まとめ

いかがでしたか？
このチャプタでは，JVM の歴史的な背景と基本的な概念について説明しました。
Java 言語は，C や C++ のような低レベルの言語ではなく，より高レベルな言語として設計されました。
JVM は Java プログラムを実行するための仮想マシンであり，特定のハードウェアやオペレーティング・システムに依存しないことが特徴です。

:::message alert

[セクション 1.3](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.3) や[セクション 1.4](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.4)，[セクション 1.5](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.5) は JVM 仕様書の表記法やフィードバックについての説明が書かれています。
このセクションは JVM の仕様を理解するためには必要な情報ではありますが，ここでは省略します。
興味のある方は，ぜひ仕様書を直接読んでみてください。
:::

次回は Chapter 2 の内容を扱います。
JVM の仕様書の第２章は「Java Virtual Machine の構造」です。
では，よいバイト・コードライフを！

#### 次回リンク

https://zenn.dev/peyang/articles/reading-jvm-chapter-02-1-4
