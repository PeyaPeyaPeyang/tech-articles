---
title: "JVM を読む - 導入"
emoji: "🧬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["java", "jvm", "jal"]
published: true
---

前回の続きです。前回はこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-00

このシリーズは，JVM の仕様書を読み解くためのガイドとして構成しています。
JVM の仕様書は非常に長大で難解な内容が多いため，各セクションごとに要点をまとめていきます。
また，JVM の内部構造や動作原理を知ることで，Java のパフォーマンスやセキュリティ，メモリ管理の仕組みを深く理解する試みです。

シリーズはこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-00

## 第一章 Introduction

JVM の仕様書の最初のセクションは「Introduction」です。
このセクションでは，JVM の目的や設計目標，基本的な概念について説明されています。

## 1.1 歴史的な背景をちょこっと（[› 1.1 A Bit of History](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.1))

Java 言語は，C や C++ のような低レベルな言語ではなく，それよりも言語サポートが手厚い高レベルな言語として設計されました。
例に上げたような低レベルな言語はハードウェアに近いレベルでの制御が可能ですが， その分，メモリ管理やポインタ操作などの複雑な概念を理解する必要があります（さらに，安全なコードを書くためにはそれらを正確に扱う必要があります）。
全くもって複雑で分かりにくく，少しも安全ではなかったのです。

そこで， Java の設計者たちはこれらの問題を解決するために Java をより高レベルな言語として設計しました。

### Web の登場とその限界

さて，少し昔話をしましょう。
Java 言語は 1995 年に Sun Microsystems 社に所属する James Gosling 氏（別名，Dr. Java）によって開発されました。
この頃の Web サイトは HTML だけで書かれており，そのうえ，  動的にコンテンツを生成する仕組み（例えば JavaScript のような仕組み）はありませんでした。

HTML は，皆さんご存知の通り静的なマークアップ言語ですから，動的な要素（例えばボタンを押したときに何かが起こるようにするなど）をページに追加することはできません。
こういった生 HTML の勝手の悪さに Web の愛好家はすぐに気がつきました。新たな解決策が必要だったのです。

そこで登場したのが *HotJava ブラウザ*をはじめとしたアプレット技術です。
これは **HTML ページ内にプログラムを埋め込む**ことで，**ページに動的な要素を追加**できるという画期的なものでした。
ユーザがアプレットが埋め込まれたページをブラウザで開くと，アプレットがユーザの端末で実行されて動的なコンテンツが表示されます。
もちろん，通常の HTML もそれと同時に読み込まれて表示されます。

このようにして，Web ページに動的なコンテンツがもたらされました。 この技術は瞬く間に普及し，Web ページの表現力を大きく向上させました。

アプレットが普及した理由には，単に見栄えや機能が良いからというだけはありません。
実は *JVM のアーキテクチャ*や Java の*セキュリティ・モデル*が大きく貢献しています。

#### 普及の理由その１：JVM のアーキテクチャ

アプレットは，アプレットが埋め込まれたページを閲覧するユーザの端末で実行されます。
ということは，プログラムは**あらゆるユーザが所有する，あらゆるマシン**で動作することになります。

通常のプログラム（C や C++ などで記述されたもの）は，特定のハードウェアやオペレーティング・システムに依存してコンパイルされます。
例えば，Windows 用にコンパイルされたプログラムは Linux では動作しませんし，Intel x86 CPU 用にコンパイルされたプログラムは ARM CPU では動作しません。
したがって，アプレットが動作するためには，オプションを変えながら各マシン用のバイナリを都度コンパイルする必要があるのです。
しかしながら，これに対応するのは非常に面倒で，また大変非効率的なように思えます。度し難いですね。

:::message
もしここで使っているマシンのアンケートを取ったとしたら，私は「Intel x86 CPU で動く Windows 11」に投票しようと思いますが，
この記事を読んでいる皆さんは違った環境に投票をするかもしれません。
このようにユーザの環境は多様であり，それぞれに対応するのは骨の折れる作業です。
:::

そこで登場したのが JVM（Java 仮想マシン） というわけです。

Java プログラムは，まず Java ソース・コードからバイト・コード（JVM が理解できる専用の中間言語）にコンパイルされます。
JVM は，このバイト・コードを読み取り，自身が構築した箱庭（仮想マシン）の中で順次実行します。

さらに，JVM は自身が動作するマシンのハードウェアやオペレーティング・システムに依存しません。
JVM は抽象的な計算機であり，JVM がどのような環境で動作しているかについては，JVMの中では一切関係がないのです。

:::message
私は，しばしば JVM を「コンセントの変換アダプタ」に例えます。
私が使っている「業務用赤外線魚焼き器」は，日本の一般家庭で広く使われている２ピンの 100 V コンセントで動作します。
しかし，これをイギリスで使うためには，イギリスの３ピン 230 V コンセントに対応する魚焼き器を買う必要があります。 セントビンセント・グレナディーン諸島で使うためには，さらに別の魚焼き器を買う必要があります。

もしここで，魚焼き器を買い換える代わりに，変換アダプタを使えたらどうでしょうか。
変換アダプタさえあれば，買うべき魚焼き器は１つで済み，あとは対応する変換アダプタを買うだけで済みます。

JVM でも同様です。
Java プログラムは JVM バイト・コードという「変換アダプタが理解できる形式」にコンパイルされます。JVM という「変換アダプタ」があれば，あらゆるマシンで１つの Java プログラムを動作させられるのです。
:::

さて，これにより Java プログラムは「*Write Once, Run Anywhere*」（一度書けばどこでも動く）という標語の通り，**あらゆるマシンで動作する**ようになりました。
当時のアプレット技術を用いることで，あらゆるユーザの端末で動作する動的なコンテンツを，たった１つのバイナリで実現できるようになったのです。

#### 普及の理由その２：Java のセキュリティモデル

先ほど述べたように，アプレットはユーザの端末で実行されます。これは，アプレットがユーザのマシンに直接アクセスできてしまうことを意味します。
もし Web ページに埋め込まれたプログラムが，任意のユーザのファイルやシステムにアクセスできるとしたら，当然セキュリティ上の問題が発生します。
そこで Java は，**アプレットが実行される環境を制限するためのセキュリティモデル**を導入しました。

Java のセキュリティ・モデルでは，アプレットを隔離された環境（**サンドボックス**）で実行します。
サンドボックス内では，アプレットがユーザのファイルシステムやネットワークにアクセスできないように制限されます。

アプレットは，特定の権限を持つ場合にのみ，ユーザのマシンにアクセスできます。
例えば，アプレットがユーザのファイルシステムにアクセスするためには，ユーザが明示的に許可する必要があります。
このようにして，アプレットはユーザのマシンに対して安全に動作するのです。

このことが当時のギークたちに受け入れられると， Java 使っているページは安全であるという一種の信頼を得ることとなり，これもまたアプレット技術の普及に寄与しました。

#### まとめ

アプレット技術は，JVM のアーキテクチャと Java のセキュリティモデルによって支えられています。
これにより，Java プログラムは「*Write Once, Run Anywhere*」の特性を持ち，ユーザの端末で安全に動作することが可能となりました。
今ではアプレット技術は廃れてしまいましたが，JVM のアーキテクチャと Java のセキュリティモデルは，Java 言語の基盤として確かに受け継がれています。

## 1.2 Java 仮想マシン（[› 1.2 The Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.2)）

Java 仮想マシン（JVM）は，Java プログラムを実行するための仮想マシンです。
JVM は Java Virtual Machine Specification という仕様書で，扱う命令やその振る舞いなどが厳密に定義されています。

JVM は次のような特徴を持っています：

1. 特定のハードウェアやオペレーティング・システムなどの**環境に依存しない**こと
2. コンパイルされた**バイナリのサイズが小さい**こと
3. 悪意のあるプログラムからユーザを保護するための**セキュリティ機能を備えている**こと

これらの特徴により，Java 仮想マシンはプラットフォームに依存しないアプリケーションの最高な実行環境を提供します。

### JVM の最初の実装

Java 仮想マシンの最初の実装は，Sun Microsystems 社によって行われました。
この実装は現代の PDA（携帯電話のような見た目の小型コンピュータ。）に似ているデバイス上で行われ，PDA では Java 仮想マシンが動作し，Java アプリケーションを実行できました。

Oracle 社がする現在の実装では，こういった環境に限らずモバイルやデスクトップ，さらにはサーバ上で Java 仮想マシンを実行します。
しかしながら Java 仮想マシンは依然として抽象的な計算機であり，特定の実装技術やホスト，ハードウェアやオペレーティング・システムに依存しません。
すなわち，例えばシリコン CPU やマイクロコードに直接実装することもできますし，他の言語で実装することも， JVM 上で JVM を実装することもできます。

:::message
例えば [picoJava](https://picojava-ii.github.io/) は Java 仮想マシンの命令セットを**ハードウェアで実装**したものです。
picoJava は Sun Microsystems 社によって開発され，Java 仮想マシンの命令を CPU の命令として，ハードウェアで直接実行します。
すなわち，Java 仮想マシン を仮想的なものではなく，物理的なものとして実装したわけです。
:::

### まとめ

いかがでしたか？
このチャプタでは，JVM の歴史的な背景と基本的な概念について説明しました。
Java 言語は，C や C++ のような低レベルの言語ではなく，より高レベルな言語として設計されました。
JVM は Java プログラムを実行するための仮想マシンであり，特定のハードウェアやオペレーティング・システムに依存しないことが特徴です。

:::message alert

[セクション 1.3](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.3) や[セクション 1.4](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.4)，[セクション 1.5](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.5) は JVM 仕様書の表記法やフィードバックについての説明が書かれています。
このセクションは JVM の仕様を理解するためには必要な情報ではありますが，ここでは省略します。
興味のある方は，ぜひ仕様書を直接読んでみてください。
:::

次回は Chapter 2 の内容を扱います。
JVM の仕様書の第２章は「Java Virtual Machine の構造」です。
では，よいバイト・コードライフを！

#### 次回リンク

https://zenn.dev/peyang/articles/reading-jvm-chapter-02-1-4

#### 参考文献＆リンク集

+ Lindholm, T., Yellin, F., Bracha, G., & Smith, W. M. D. (2025). [*The Java® Virtual Machine Specification: Java SE 24 Edition*](https://docs.oracle.com/javase/specs/jvms/se24/html/). 
+ Lindholm, T., & Yellin, F. (1999). *The Java™ Virtual Machine Specification* (2nd ed.). Addison-Wesley. ISBN 978-0-201-43294-7
+ Otavio, S. (2024). *Mastering the Java Virtual Machine*.  Packet Publishing. ISBN 978-1-835-46796-1
