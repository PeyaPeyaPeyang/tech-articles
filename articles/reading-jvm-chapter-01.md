---
title: "JVM を読む - 導入"
emoji: "🧬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["java", "jvm", "jal"]
published: true
---

前回の続きです。前回はこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-00

このシリーズは，JVM の仕様書を読み解くためのガイドとして構成しています。
JVM の仕様書は非常に長大で難解な内容が多いため，各セクションごとに要点をまとめていきます。
また，JVM の内部構造や動作原理を知ることで，Java のパフォーマンスやセキュリティ，メモリ管理の仕組みを深く理解する試みです。

シリーズはこちらから。

https://zenn.dev/peyang/articles/reading-jvm-chapter-00

## 第一章 Introduction

JVM の仕様書の最初のセクションは「Introduction」です。
このセクションでは，JVM の目的や設計目標，基本的な概念について説明されています。

## 1.1 歴史的な背景をちょこっと（[› 1.1 A Bit of History](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.1))

Java 言語は，C や C++ のような低レベルな言語ではなく，それよりも言語サポートが手厚い高レベルな言語として設計されました。
例に上げたような低レベルな言語は，ハードウェアに近いレベルでの制御が可能ですが，
その分，メモリ管理やポインタ操作などの複雑な概念を理解する必要があります（さらに，安全なコードを書くためにはそれらを正確に扱う必要があります）。
そのため全くもって複雑で，分かりにくく，また安全ではありません。

そこで， Java の設計者たちは，これらの問題を解決するために Java をより高レベルな言語として設計しました。

### Web の登場とその限界

ところで，この頃（90年代）の Web サイトは HTML だけで書かれていました。
そのうえ，動的にコンテンツを生成する仕組み（例えば JavaScript のような仕組み）はありませんでした。

HTML は，皆さんご存知の通り静的なマークアップ言語ですから，動的な要素（例えばボタンを押したときに何かが起こるなど）をページに追加することはできません。
こういった生 HTML の勝手の悪さに Web の愛好家はすぐに気がつきました。新たな解決策が必要だったのです。

そこで登場したのが *HotJava ブラウザ*をはじめとしたアプレット技術です。
これは HTML ページ内にプログラムを埋め込むことで，ページに動的な要素を追加できるという画期的なものでした。
ユーザがブラウザでアプレットが埋め込まれたページを開くと，アプレットがユーザの端末で実行され，動的なコンテンツが表示されます。
もちろん，通常の HTML もそれと同時に読み込まれて表示されます。

このようにして，Web ページに動的なコンテンツがもたらされました。
この技術は非常に人気があり，広く普及しました。

アプレットが普及した理由には，単に見栄えや機能が良いからというだけでなく，*JVM のアーキテクチャ*や Java の*セキュリティ・モデル*が大きく貢献しています。

#### 普及の理由その１：JVM のアーキテクチャ

アプレットは，それが埋め込まれたページを表示する時に，そしてそのページを閲覧するユーザの端末で実行されます。
ということは，プログラムは**あらゆるユーザが所有する，あらゆるマシン**で動作することになります。

通常のプログラムは，特定のハードウェアやオペレーティング・システムに依存してコンパイルされます。
例えば，Windows 用にコンパイルされたプログラムは Linux では動作しませんし，Intel x86 CPU 用にコンパイルされたプログラムは ARM CPU では動作しません。
したがって，アプレットが動作するためには，オプションを変えながら各マシン用のバイナリを都度コンパイルする必要があるのでしょうか。
これに対応するのは非常に面倒で，また非効率的なように思えます。

:::message
もしここで使っているマシンのアンケートを取ったとしたら，私は「Intel x86 CPU で動く Windows 11」に投票しようと思いますが，
この記事を読んでいる皆さんは違った環境に投票をするかもしれません。
このようにユーザの環境は多様であり，それぞれに対応するのは骨の折れる作業です。
:::

そこで登場したのが JVM（Java 仮想マシン） というわけです。

JVM とは Java バイト・コードを読み取って実行する仮想マシンです。
Java プログラムは，まず Java ソース・コードからバイト・コード（JVM が理解できる専用の中間言語）にコンパイルされます。
JVM は，このバイト・コードを読み取り，実行します。

さらに，JVM はJVMが動作するマシンのハードウェアやオペレーティング・システムに依存しません。
JVM は抽象的な計算機であり，JVM がどのような環境で動作しているかについては，JVMの中では一切関係がないのです。

これにより，Java プログラムは「*Write Once, Run Anywhere*」（一度書けばどこでも動く）という標語の如き機能を得ました。
当時のアプレット技術は，この特性を活かしてユーザの端末で動作する動的なコンテンツを簡単に提供できるようになったのです。

#### 普及の理由その２：Java のセキュリティモデル

先ほど述べたように，アプレットはユーザの端末で実行されます。これは，アプレットがユーザのマシンに直接アクセスできることを意味します。
もし Web ページに埋め込まれたプログラムが，任意のユーザのファイルやシステムにアクセスできるとしたら，当然セキュリティ上の問題が発生します。
そこで Java は，**アプレットが実行される環境を制限するためのセキュリティモデル**を導入しました。

Java のセキュリティ・モデルでは，アプレットを隔離された環境（**サンドボックス**）で実行します。
サンドボックス内では，アプレットがユーザのファイルシステムやネットワークにアクセスできないように制限されます。

アプレットは，特定の権限を持つ場合にのみ，ユーザのマシンにアクセスできます。
例えば，アプレットがユーザのファイルシステムにアクセスするためには，ユーザが明示的に許可する必要があります。
このようにして，アプレットはユーザのマシンに対して安全に動作するのです。

このことが当時のギークたちに受け入れられると， Java 使っているページは安全であるという一種の信頼を得ることとなり，
これもまたアプレット技術の普及に寄与しました。

#### まとめ

アプレット技術は，JVM のアーキテクチャと Java のセキュリティモデルによって支えられています。
これにより，Java プログラムは「*Write Once, Run Anywhere*」の特性を持ち，ユーザの端末で安全に動作することが可能となりました。
今ではアプレット技術は廃れてしまいましたが，JVM のアーキテクチャと Java のセキュリティモデルは，Java 言語の基盤として確かに受け継がれています。

## 1.2 Java 仮想マシン（[› 1.2 The Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.2)）

Java 仮想マシン（JVM）は，Java プログラムを実行するための仮想マシンです。
JVM は Java Virtual Machine Specification という仕様書で，扱う命令やその振る舞いなどが厳密に定義されています。

JVM は次のような特徴を持っています：

1. 特定のハードウェアやオペレーティング・システムなど，**環境に依存しない**こと
2. コンパイルされた**バイナリのサイズが小さい**こと
3. 悪意のあるプログラムからユーザを保護するための**セキュリティ機能を備えている**こと

これらの特徴により，Java 仮想マシンはプラットフォームに依存しないアプリケーションの最高な実行環境を提供します。

さらに言うと，Java 仮想マシンは抽象的な計算機です。
実際の電卓のように命令セットを持ち，実行時には様々なメモリ領域を操作します。

### JVM の最初の実装

Java 仮想マシンの最初の実装は，Sun Microsystems 社によって行われました。
この実装は現代の PDA（携帯電話のような見た目の小型コンピュータ。）に似ているデバイス上で行われ，PDA では Java 仮想マシンが動作し，Java アプリケーションを実行できました。

Oracle 社がする現在の実装では，こういった環境に限らずモバイルやデスクトップ，さらにはサーバ上で Java 仮想マシンを実行します。
しかしながら Java 仮想マシンは依然として抽象的な計算機であり，特定の実装技術やホスト，ハードウェアやオペレーティング・システムに依存しません。
すなわち，例えばシリコン CPU やマイクロコードに直接実装することもできますし，他の言語で実装することも， JVM 上で JVM を実装することもできます。

:::message
例えば [picoJava](https://picojava-ii.github.io/) は Java 仮想マシンの命令セットを**ハードウェアで実装**したものです。
picoJava は Sun Microsystems 社によって開発され，Java 仮想マシンの命令を CPU の命令として，ハードウェアで直接実行します。
すなわち，Java 仮想マシン を仮想的なものではなく，物理的なものとして実装したわけです。
:::

### まとめ

いかがでしたか？
このチャプタでは，JVM の歴史的な背景と基本的な概念について説明しました。
Java 言語は，C や C++ のような低レベルの言語ではなく，より高レベルな言語として設計されました。
JVM は Java プログラムを実行するための仮想マシンであり，特定のハードウェアやオペレーティング・システムに依存しないことが特徴です。

:::message alert

[セクション 1.3](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.3) や[セクション 1.4](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.4)，[セクション 1.5](https://docs.oracle.com/javase/specs/jvms/se24/html/jvms-1.html#jvms-1.5) は JVM 仕様書の表記法やフィードバックについての説明が書かれています。
このセクションは JVM の仕様を理解するためには必要な情報ではありますが，ここでは省略します。
興味のある方は，ぜひ仕様書を直接読んでみてください。
:::

次回は Chapter 2 の内容を扱います。
JVM の仕様書の第２章は「Java Virtual Machine の構造」です。
では，よいバイト・コードライフを！

#### 次回リンク

https://zenn.dev/peyang/articles/reading-jvm-chapter-02-1-4

#### 参考文献＆リンク集

+ Lindholm, T., Yellin, F., Bracha, G., & Smith, W. M. D. (2025). [*The Java® Virtual Machine Specification: Java SE 24 Edition*](https://docs.oracle.com/javase/specs/jvms/se24/html/). 
+ Lindholm, T., & Yellin, F. (1999). *The Java™ Virtual Machine Specification* (2nd ed.). Addison-Wesley. ISBN 978-0-201-43294-7
+ Otavio, S. (2024). *Mastering the Java Virtual Machine*.  Packet Publishing. ISBN 978-1-835-46796-1
