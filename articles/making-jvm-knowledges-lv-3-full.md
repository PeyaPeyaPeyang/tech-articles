---
title: "【ミニマルな】 Java 仮想マシンを自作したい全ての方々へ"
emoji: "☕"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["java", "jvm", "jal"]
published: false
---

## はじめに

この記事は，[Java 仮想マシンを自作したい全ての方々へ](https://zenn.dev/peyang/articles/making-jvm-knowledges) の子記事のようななものです。
上記の記事では，JVM の実装に必要な知識をまとめましたが，実際に JVM を実装するのは大変なことです。
そこで，JVM の実装を ４段階にレベル分けして，それぞれの概要を述べました。

この記事では，その中で最も簡単な「実装レベル2: 基本的な機能を備えたミニマルな JVM」を実装するために必要な知識とリソースをまとめます。
なお，この記事も，JVM を自作するための詳細な手順やチュートリアルを提供するものではありません。

## 実装レベル2: 基本的な機能を備えたミニマルな JVM とは

実装レベル2 のJVM は，メソッド呼び出しや制御フローなどの基本的な機能を備えたミニマルな JVM で，この図の黄色の部分に相当します。

![JVM レベル2](/images/making-jvm-knowledges/jvm-implementation-levels.png)

### 例外の発生と処理

例外は，プログラムの実行中に発生する異常な状況を表現するための仕組みです。 例えば，ゼロ除算や配列の範囲外アクセスなどが例外の一例です。
プログラムが明示的に発生させるもの以外にも，JVM 自体が発生させる例外もあります。

例外は，以下のいずれかの事象の発生とともにスローされます：

1. `athrow` 命令をプログラムが実行されたとき
2. JVM 内部でエラーが発生したとき（非同期的な例外となる）
3. JVM によってプログラムの異常が検出されたとき

特に，「3 JVM によってプログラムの異常が検出されたとき」では，JVM はプログラムの異常を検出して適切な例外をスローします。
これは**コードの実行中に任意のタイミングで発生するものではなく**，特に以下の場合にJVMが例外をスローします：

1. **命令が不正な操作を実行しようとしたとき**
   例えば…
  - 配列の範囲外へのアクセス
  - `null` 参照へのアクセス
  - 不正なキャスト
  - その他 Java 言語のセマンティクスに違反する操作
2. **リソースの不足が発生したとき**
   例えば…
  - メモリ不足
  - スタックオーバーフロー
  - その他のリソース制約に違反する操作

#### 例外の処理：例外テーブルの探索

JVM は，或るメソッドの実行中に例外が発生した場合には，そのメソッドの「**例外テーブル**」を参照して有効な例外ハンドラを探索します。

例外テーブルとは，メソッドの `Code` 属性に含まれるテーブルで，以下の情報を持つエントリの集合です：
- **開始位置**: この例外ハンドラの有効範囲の開始位置（オフセット）
- **終了位置**: 有効範囲の終了位置（オフセット）
- **ハンドラの開始位置**: 例外が発生した場合に制御が移る命令の位置
- **例外型**: このハンドラが処理する例外の型（指定されていない場合は，すべての例外を処理できる）

例外が発生した場合，JVM は現在実行中の命令のオフセットを取得し，例外テーブルを**上から順に**探索します。 各エントリについて，JVM は以下の条件を満たすかどうかについて次の２点を確認します：
1. 現在の命令のオフセットが，エントリの開始位置と終了位置の範囲内にあること
2. 発生した例外の型が，エントリの例外型と一致するか，またはそのサブクラスであること

これらの条件を満たすエントリが見つかった場合，JVM はそのエントリのハンドラの開始位置に制御を移し，例外処理を開始します。

例外テーブルの探索処理を実装する際には，以下の点に注意する必要があります：
+ **例外テーブルの探索順序**: 例外テーブルは上から順に探索する必要があります。
  通常の `javac` コンパイラは `finally` ブロックのための *Catch-all* エントリ（例外型が指定されていないエントリ）を例外テーブルの最後に配置します。 そのため，特定の例外型を処理するエントリが *Catch-all* エントリよりも前にあることを保証する必要があります。
+ **例外型を指定しないエントリの扱い**: 例外型が指定されていないエントリ（*Catch-all エントリ*）は，すべての例外を処理できることを意味します。
  例外型が指定されていないからと言って，不正な例外型を指定しているわけではないことに注意してください。 例えば，`finally` ブロックのための *Catch-all* エントリは，すべての例外を処理できるように設計されています。
